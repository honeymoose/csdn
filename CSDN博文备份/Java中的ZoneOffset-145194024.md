<h3>介绍</h3> <br><p>在我们的这个世界上因为地球是圆的，所以每个国家都会有自己特定的时区。</p> <br><p>时区在我们对时间的使用上扮演了非常重要的角色。但又因为时区的存在，又给我们带来了很多的麻烦，比如北美地区使用的夏令时和中国统一使用东 8 区的时间等。</p> <br><p></p> <br><p></p> <br><p class="img-center"><a href="https://cdn.isharkfly.com/com-isharkfly-www/discourse-uploads/original/3X/1/5/15f64a7459e242d328b7e184c49eb63e45f1449b.jpeg" rel="nofollow"><img alt="2025-01-16_10-24-57" height="500" src="https://i-blog.csdnimg.cn/img_convert/2cf7d77b028ea510d04088d1556e971d.jpeg" width="661" /></a></p> <br><p></p> <br><p>当这些时间在我们计算机中进行体现的时候就会给我们带来不少的麻烦，为了解决这些麻烦，Java 提供了一些 API 来进行处理，比如用到的 <em>Date</em>，<em>Time</em> 和 <em>DateTime</em>。</p> <br><p>我们都知道，Java 的时间处理因为 API 的使用会变得非常的繁琐，所以在新的版本 Java 中，Java 尝试解决这个问题，为此开始提供 <em>ZoneId</em> 和 <em>ZoneOffset</em> API 来管理时区。</p> <br><p>在本文中，我们将会对 <em>ZoneId</em> 和<em>ZoneOffset</em> 进行一些探讨，同时也对 <em>DateTime</em> 类进行一些探索。</p> <br><h3><em>ZoneId</em> 和 <em>ZoneOffset</em></h3> <br><p>在 <a href="https://jcp.org/en/jsr/detail?id=310" rel="nofollow" title="JSR-310">JSR-310</a> 发布的版本中，Java 添加了一些 API 用来管理日期，时间和有时区的时间。</p> <br><p><em>ZoneId</em> 和 <em>ZoneOffset</em> 类做为上面更新的一部分也同时添加到了 Java 中。</p> <br><h4>ZoneId</h4> <br><p>*<em>ZoneId</em> 在 Java 中被用来表示时区，例如 ‘<em>Europe/Paris</em>‘.</p> <br><p>针对 ZoneId 有 2 个实现，第一个实现是针对 GMT/UTC 来计算偏移量。</p> <br><p>第二个实现为使用距离的地理区域，这会针对 GMT/UTC 对比来进行一系列的计算。</p> <br><p>让我们来创建一个 Berlin, Germany 的 ZoneId 实例。</p> <br><p></p> <br><pre><code>ZoneId zone = ZoneId.of("Europe/Berlin");<br></code></pre> <br><p>针对中国可以使用的时间定义为标准北京时间。</p> <br><p></p> <br><pre><code>        ZoneId zoneId = ZoneId.of("Asia/Shanghai");<br></code></pre> <br><p>但使用的时间字符串为上海。</p> <br><h4>ZoneOffset</h4> <br><p>ZoneOffset 集成了 ZoneId 同时来定义了当前使用的时区针对 GMT/UTC 的偏移量，例如：+02:00。</p> <br><p>这就意味这个这个数字表示的是针对 UTC 标准时间使用的固定小时和分钟数。</p> <br><p></p> <br><pre><code>        LocalDateTime now = LocalDateTime.now();<br>        ZoneId zone = ZoneId.of("Asia/Shanghai");<br>        ZoneOffset zoneOffSet = zone.getRules().getOffset(now);<br>        logger.debug("zoneOffSet: {}", zoneOffSet);<br></code></pre> <br><p>上面代码的输出为：</p> <br><p></p> <br><pre><code>09:13:25.045 [main] DEBUG com.ossez.datetime.DateTimeZoneUnitTest - zoneOffSet: +08:00<br></code></pre> <br><p>因为北京使用的是东八区的时间。</p> <br><p>针对同一个国家可能有 2 个针对 UTC 时间的偏移量——这些国家主要是使用夏令时的国家。比如说美国就是一个使用夏令时的国家。</p> <br><p>因此，针对这些国家 <em>ZoneOffset</em> 就会有 2 个实现了，具体需要参考 <em>LocalDateTime</em>* API 中的实现。</p> <br><h3>DateTime 类</h3> <br><p>下一个，让我们来讨论下 <em>DateTime</em> 类，这个类实际上将会使用 <em>ZoneId</em> 和 <em>ZoneOffset</em>。</p> <br><h4>ZonedDateTime</h4> <br><p><em>ZonedDateTime</em> 是不可变（immutable ）的实现，这个用来输出一个基于 ISO-8601 表达方式的时间。</p> <br><p>例如： <em>2007-12-03T10:15:30+01:00 Europe/Pari</em>。</p> <br><p>一个 <em>ZonedDateTime</em> 将会表达有 3 个部分，分别为<em>LocalDateTime</em>， <em>ZoneId</em> 和 <em>ZoneOffset</em>。</p> <br><p>这个类将会保存有所有的日期和时间字段来精确的表达时间，时区和时区偏移量。</p> <br><p>我们用这个来处理模糊的本地时间。</p> <br><p>例如：, <em>ZonedDateTime</em> 可以保存值 “2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone”。</p> <br><p>让我们使用 <em>ZonedDateTime</em> 来显示当前的时间。</p> <br><p></p> <br><pre><code>    @Test<br>    public void ZonedDateTime_out() {<br>        ZoneId zone = ZoneId.of("Asia/Shanghai");<br>        ZonedDateTime date = ZonedDateTime.now(zone);<br>        logger.debug("date: {}", date);<br>    }<br></code></pre> <br><p>上面程序的输出为：</p> <br><p></p> <br><pre><code>09:32:04.549 [main] DEBUG com.ossez.datetime.DateTimeZoneUnitTest - date: 2025-01-16T22:32:04.547368100+08:00[Asia/Shanghai]<br><br></code></pre> <br><p>从实例化的输出来看，保留了非常多的时间信息。</p> <br><p>我的计算机是现在东部时间，可以看到获得的实例已经转换成了北京时间。</p> <br><p>ZonedDateTime 同时还提供了内置函数来从一个时区转换为另外的一个时区。</p> <br><p></p> <br><pre><code>ZonedDateTime destDate = sourceDate.withZoneSameInstant(destZoneId);<br></code></pre> <br><h4>OffsetDateTime</h4> <br><p><em>OffsetDateTime</em> 是不可变的的一个日期时间，这个日期时间使用的是针对 UTC 的偏移量来进行保存的，同样使用 ISO-8601 格式。</p> <br><p>例如：<em>2007-12-03T10:15:30+01:00</em>.</p> <br><p>这个类将会保存有所有的日期和时间字段来精确的表达时间，时区和时区偏移量。</p> <br><p>例如：<em>OffsetDateTime</em> 可以寸尺值 “2nd October 2007 at 13:45.30.123456789 +02:00”。</p> <br><p>让我们来获得针对 GMT/UTC 2 小时偏移量的 <em>OffsetDateTime</em> ：</p> <br><p></p> <br><pre><code>ZoneOffset zoneOffSet= ZoneOffset.of("+02:00");<br>OffsetDateTime date = OffsetDateTime.now(zoneOffSet);<br></code></pre> <br><h4>OffsetTime</h4> <br><p><em>OffsetTime</em> 是不可变的的一个时间。</p> <br><p>通常这个时间使用 hour-minute-second-offset 来进行表达，在 ISO-8601 日历系统中将会输出为：： <em>10:15:30+01:00</em>。</p> <br><p>这个类只会存储时间，不会对日期进行存储。</p> <br><p>可以使用 “13:45.30.123456789+02:00” 来对其初始化。</p> <br><p>让我们来获得 <em>OffsetTime</em> 2 个时区的偏离量：</p> <br><p></p> <br><pre><code>ZoneOffset zoneOffSet = ZoneOffset.of("+02:00");<br>OffsetTime time = OffsetTime.now(zoneOffSet);<br></code></pre> <br><h3>结论</h3> <br><p><em>ZoneOffset</em> 通常用来处理针对 GMT/UTC 不同时区的偏移量。</p> <br><p>同时 <em>ZoneId</em> 和 <em>ZoneOffset</em> 不会单独使用，通常会结合 DateTime 的时间类来使用。</p> <br><p>例如 Java 中使用的 <em>ZonedDateTime</em>, <em>OffsetDateTime</em>, 和 <em>OffsetTime</em>。</p> <br><p></p> <br><p><a class="has-card" href="https://www.isharkfly.com/t/java-zoneoffset/16803" rel="nofollow" title="Java 中的 ZoneOffset - Java - iSharkFly"><span class="link-card-box"><span class="link-title">Java 中的 ZoneOffset - Java - iSharkFly</span><span class="link-desc">介绍在我们的这个世界上因为地球是圆的，所以每个国家都会有自己特定的时区。 时区在我们对时间的使用上扮演了非常重要的角色。但又因为时区的存在，又给我们带来了很多的麻烦，比如北美地区使用的夏令时和中国统一使用东 8 区的时间等。 当这些时间在我们计算机中进行体现的时候就会给我们带来不少的麻烦，为了解决这些麻烦，Java 提供了一些 API 来进行处理，比如用到的 Date，Time 和 DateTime。 我们都知道，Jav…</span><span class="link-link"><img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.7/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=O83A" alt="icon-default.png?t=O83A" />https://www.isharkfly.com/t/java-zoneoffset/16803</span></span></a></p>